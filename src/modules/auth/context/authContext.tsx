import { createContext, useCallback, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';

import { useStatusState } from '../hooks/useStatusState';
import {
  IAuthenticationContext,
  IWalletContent,
  IWallet,
} from '../interfaces/IAuthenticationContext';
import {
  SIGN_UP_SUCCESS_MESSAGE,
  CONFIRMATION_SENT_MESSAGE,
  UNRECOGNIZED_TOKEN_ERROR,
  SIGN_IN_SUCCESS_MESSAGE,
  SIGN_OUT_SUCCESS_MESSAGE,
} from '../message/auth-messages';
import { authService } from '../services/auth.service';

import { useToast } from '@/common/components/ui/use-toast';
import useStellar from '@/common/hooks/useStellar';
import { NETWORK } from '@/common/types/soroban.enum';
import { ApiResponseError } from '@/config/axios/errors/ApiResponseError';
import { apiService } from '@/config/axios/services/api.service';
import { StoredCookies } from '@/modules/cookies/interfaces/cookies.enum';
import { cookieService } from '@/modules/cookies/services/cookie.service';
import { WalletType } from '@/modules/signer/constants/enums';
import signerConnectWallet from '@/modules/signer/functions/connectWallet';

export const AuthContext = createContext<IAuthenticationContext | null>(null);

export function AuthProvider({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  const { statusState, setStatusState } = useStatusState();
  const { createNewAccount, fundingAccount } = useStellar();

  const navigate = useNavigate();
  const { toast } = useToast();

  const setConnectWallet = useCallback(
    (wallet: IWalletContent): void => {
      try {
        cookieService.setWalletCookie(wallet);
      } catch (error) {
        toast({
          title: 'Error',
          description: 'Failed to save wallet to local storage',
          variant: 'destructive',
        });
      }
    },
    [toast],
  );

  const onCreateAccountEphimeral = useCallback(
    async (urlEphimeral: string) => {
      try {
        setStatusState('wallet', { loading: true });
        const existingWallet = cookieService.getWalletCookie(NETWORK.EPHEMERAL);
        if (existingWallet) {
          return;
        }
        const keypair = createNewAccount();
        const response = await fundingAccount({
          publicKey: keypair.publicKey as string,
          urlEphimeral,
        });
        if (response)
          setConnectWallet({
            publicKey: keypair.publicKey as string,
            type: WalletType.SECRETKEY,
            network: NETWORK.EPHEMERAL,
            autoGenerated: true,
            privateKey: keypair.secretKey,
            email: cookieService.getCookie(StoredCookies.EMAIL) ?? null,
          });
      } finally {
        setStatusState('wallet', { loading: false });
      }
    },
    [createNewAccount, fundingAccount, setConnectWallet, setStatusState],
  );

  const onDeleteAccountEphimeral = useCallback(async () => {
    try {
      setStatusState('wallet', { loading: true });
      cookieService.removeWalletCookie(NETWORK.EPHEMERAL);
    } catch (error) {
      toast({
        title: 'Error',
        description: 'Failed to delete account',
        variant: 'destructive',
      });
    } finally {
      setStatusState('wallet', { loading: false });
    }
  }, [setStatusState, toast]);

  const onCreateAccount = useCallback(
    (
      showToast = true,
      refreshSession = false,
      wallets: IWallet = cookieService.getAllWalletCookies(),
      email: string = cookieService.getCookie(StoredCookies.EMAIL) ?? '',
    ) => {
      try {
        setStatusState('wallet', { loading: true });
        const keypair = createNewAccount();
        for (const network of [
          NETWORK.SOROBAN_TESTNET,
          NETWORK.SOROBAN_FUTURENET,
        ]) {
          if (
            refreshSession &&
            wallets[network] &&
            !wallets[network]?.autoGenerated &&
            wallets[network]?.email === email
          )
            continue;
          else if (keypair?.publicKey && keypair?.secretKey) {
            fundingAccount({ network, publicKey: keypair.publicKey });
            setConnectWallet({
              publicKey: keypair.publicKey,
              type: WalletType.SECRETKEY,
              network: network as unknown as NETWORK,
              autoGenerated: true,
              privateKey: keypair.secretKey,
              email: cookieService.getCookie(StoredCookies.EMAIL) ?? null,
            });
          }
        }
        if (showToast)
          toast({
            title: 'Account Created Successfully',
            description: 'Account created and funded on Testnet and Futurenet',
          });
      } catch (error) {
        toast({
          title: 'Error',
          description: 'Failed to create account',
          variant: 'destructive',
        });
      } finally {
        setStatusState('wallet', { loading: false });
      }
    },
    [createNewAccount, fundingAccount, setConnectWallet, setStatusState, toast],
  );

  const disconnectWallet = useCallback(
    (network?: Partial<NETWORK> | null, showToast = true): void => {
      try {
        if (network) {
          cookieService.removeWalletCookie(network);
          showToast &&
            toast({
              title: `Disconnected wallet from ${
                network.charAt(0).toUpperCase() +
                network.toLocaleLowerCase().slice(1)
              }`,
              description: 'Wallet disconnected successfully',
            });
          onCreateAccount(false, true);
        } else {
          cookieService.removeAllWalletCookies();
          showToast &&
            toast({
              title: 'Disconnected wallets',
              description: 'Wallets disconnected successfully',
            });
        }
      } catch (error) {
        toast({
          title: 'Error',
          description: 'Failed to disconnect wallet',
          variant: 'destructive',
        });
      }
    },
    [onCreateAccount, toast],
  );

  const connectWallet = useCallback(
    async (network: NETWORK): Promise<void> => {
      try {
        setStatusState('wallet', { loading: true });
        let response = await signerConnectWallet(network);
        if (!response?.publicKey || !response?.wallet)
          response = await signerConnectWallet(network);
        if (!response?.publicKey || !response?.wallet)
          throw new Error('Failed to connect wallet');
        setConnectWallet({
          publicKey: response.publicKey,
          type: response.wallet,
          network: network as unknown as NETWORK,
          email: cookieService.getCookie(StoredCookies.EMAIL) ?? null,
          autoGenerated: false,
        });
        toast({
          title: `Connected wallet to ${
            network.charAt(0).toUpperCase() +
            network.toLocaleLowerCase().slice(1)
          }`,
          description: 'Wallet connected successfully',
        });
      } catch (err: unknown) {
        console.error(err);

        if (err instanceof Error) {
          toast({
            title: "Couldn't connect wallet",
            description: err.message,
            variant: 'destructive',
          });
        }

        toast({
          title: 'Error',
          description: 'Please try again',
          variant: 'destructive',
        });
      }
      setStatusState('wallet', { loading: false });
    },
    [setConnectWallet, setStatusState, toast],
  );

  const handleSignUp = useCallback(
    async (email: string, password: string) => {
      async function signUp(email: string, password: string) {
        setStatusState('signUp', {
          loading: true,
        });
        try {
          const response = await authService.signUp(email, password);
          if (response.success && response.statusCode === 201) {
            toast({
              title: SIGN_UP_SUCCESS_MESSAGE,
              description: CONFIRMATION_SENT_MESSAGE,
            });
            setStatusState('signUp', {
              status: true,
              error: null,
              loading: false,
            });
            setStatusState('signIn', {
              error: null,
              loading: false,
            });
            navigate('/auth/login');
          } else {
            throw new Error('Failed to sign up');
          }
        } catch (error) {
          setStatusState('signUp', {
            status: false,
            error: null,
            loading: false,
          });
          if (error instanceof ApiResponseError) {
            setStatusState('signUp', { error: error.details.description });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when requesting creation of user: ${error}`,
              variant: 'destructive',
            });
          }
        } finally {
          setStatusState('signUp', {
            loading: false,
          });
        }
      }
      return signUp(email, password);
    },
    [navigate, setStatusState, toast],
  );

  const handleSignIn = useCallback(
    async (email: string, password: string) => {
      async function signIn(email: string, password: string) {
        setStatusState('signIn', {
          loading: true,
          error: null,
        });
        try {
          const response = await authService.signIn(email, password);
          const { payload } = response;
          const { accessToken, refreshToken, idToken, user } = payload;
          const decodedToken = cookieService.decodeToken(idToken);
          if (!decodedToken) throw new Error(UNRECOGNIZED_TOKEN_ERROR);

          cookieService.setAccessTokenCookie(accessToken);
          cookieService.setMemoIdCookie(user.memoId);
          cookieService.setBalanceCookie(user.balance);
          cookieService.setUserIdCookie(user.id);
          cookieService.setRefreshTokenCookie(refreshToken, decodedToken.exp);
          cookieService.setEmailCookie(email, decodedToken.exp);
          apiService.setAuthentication(accessToken);
          onCreateAccount(false, true);
          toast({
            title: SIGN_IN_SUCCESS_MESSAGE,
            description: `Welcome back, ${email}`,
          });
          setStatusState('signIn', { status: true });
          navigate('/');
        } catch (error) {
          setStatusState('signIn', { status: false });
          if (error instanceof ApiResponseError) {
            setStatusState('signIn', { error: error?.details?.description });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when requesting user sign in: ${error}`,
              variant: 'destructive',
            });
          }
        } finally {
          setStatusState('signIn', {
            loading: false,
          });
        }
      }
      return signIn(email, password);
    },
    [setStatusState, onCreateAccount, toast, navigate],
  );

  const handleForgotPassword = useCallback(
    (email: string) => {
      async function forgotPassword(email: string) {
        setStatusState('forgotPassword', {
          loading: true,
          error: null,
        });
        try {
          const response = await authService.forgotPassword(email);
          if (response.success && response.statusCode === 200) {
            toast({
              title: 'Password recovery',
              description: 'Password recovery email sent',
            });
            setStatusState('forgotPassword', {
              status: true,
              loading: false,
            });

            setStatusState('resetPassword', {
              error: null,
              loading: false,
              status: false,
              data: email,
            });

            navigate('/auth/reset-password');
          } else {
            throw new Error('Failed to request password change');
          }
        } catch (error) {
          setStatusState('forgotPassword', {
            status: false,
            loading: false,
          });
          if (error instanceof ApiResponseError) {
            setStatusState('forgotPassword', {
              error: error.details.description,
            });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when requesting password recovery: ${error}`,
              variant: 'destructive',
            });
          }
        } finally {
          setStatusState('forgotPassword', {
            loading: false,
          });
        }
      }
      return forgotPassword(email);
    },

    [navigate, setStatusState, toast],
  );

  const handleRefreshSession = useCallback(async () => {
    setStatusState('refreshSession', { loading: true });
    try {
      const email = cookieService.getCookie(StoredCookies.EMAIL);
      const refreshToken = cookieService.getCookie(StoredCookies.REFRESH_TOKEN);
      const accessToken = cookieService.getCookie(StoredCookies.ACCESS_TOKEN);

      if (!email || !refreshToken) {
        setStatusState('refreshSession', { status: false, loading: false });
        navigate('auth/login');
        return;
      }

      if (accessToken) {
        await authService.validateToken();
        setStatusState('refreshSession', { status: true, loading: false });
        return;
      }

      const { payload } = await authService.refreshToken(email, refreshToken);
      cookieService.setAccessTokenCookie(payload.accessToken);
      apiService.setAuthentication(payload.accessToken);

      setStatusState('refreshSession', { status: true, loading: false });
    } catch (error: unknown) {
      setStatusState('refreshSession', { status: false, loading: false });
      const errorMessage =
        error instanceof ApiResponseError
          ? error.details.description
          : `Unknown error when refreshing session: ${error}`;

      setStatusState('refreshSession', { error: errorMessage });

      if (
        error instanceof ApiResponseError &&
        errorMessage === 'Invalid Refresh Token'
      ) {
        cookieService.removeAll();
        cookieService.removeAllWalletCookies();
      } else {
        toast({
          title: 'Error',
          description: 'Token expired, please sign in again',
          variant: 'destructive',
        });
      }

      setStatusState('signIn', { error: null, loading: false });
      navigate('auth/login');
    }
  }, [setStatusState, navigate, toast]);

  const handleSignOut = useCallback(() => {
    setStatusState('signOut', {
      loading: true,
    });
    try {
      cookieService.removeAll();
      apiService.setAuthentication('');
      disconnectWallet(null, false);
      toast({
        title: 'Sign out',
        description: SIGN_OUT_SUCCESS_MESSAGE,
      });
      setStatusState('signOut', {
        status: true,
        loading: false,
      });
      setStatusState('signIn', {
        error: null,
        loading: false,
      });
      navigate('/auth/login');
    } catch (error) {
      setStatusState('signOut', {
        status: false,
        loading: false,
      });
      toast({
        title: 'Error',
        description: `Unknown error when signing out: ${error}`,
        variant: 'destructive',
      });
    }
  }, [navigate, disconnectWallet, setStatusState, toast]);

  const handleResetPassword = useCallback(
    async (password: string, code: string, email?: string) => {
      const localEmail =
        cookieService.getCookie(StoredCookies.EMAIL) ??
        statusState.resetPassword.data ??
        email ??
        '';
      async function resetPassword({
        email,
        password,
        code,
      }: {
        email: string;
        password: string;
        code: string;
      }) {
        setStatusState('resetPassword', {
          loading: true,
          error: null,
        });
        try {
          const response = await authService.resetPassword(
            email,
            password,
            code,
          );
          if (response.success && response.statusCode === 200) {
            toast({
              title: 'Password reset',
              description: 'Password reset successful',
            });
            setStatusState('resetPassword', {
              status: true,
              loading: false,
            });
            setStatusState('signIn', {
              error: null,
              loading: false,
            });
            navigate('/auth/login');
          } else {
            throw new Error('Failed to reset password');
          }
        } catch (error) {
          setStatusState('resetPassword', {
            status: false,
            loading: false,
          });
          if (error instanceof ApiResponseError) {
            setStatusState('resetPassword', {
              error: error.details.description,
            });
            if (error.details.description === 'User not authorized') return;
            if (error.details.description !== 'Invalid refresh token')
              toast({
                title: 'Error',
                description: error.details.description,
                variant: 'destructive',
              });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when refreshing session: ${error}`,
              variant: 'destructive',
            });
          }
          setStatusState('resetPassword', {
            error: null,
            loading: false,
          });
          navigate('auth/login');
        }
      }
      return resetPassword({
        email: localEmail,
        password,
        code,
      });
    },
    [navigate, setStatusState, statusState.resetPassword.data, toast],
  );

  const handleChangePassword = useCallback(
    async (oldPassword: string, newPassword: string) => {
      setStatusState('changePassword', {
        loading: true,
        error: null,
      });
      try {
        const response = await authService.changePassword(
          newPassword,
          oldPassword,
        );
        if (response.success && response.statusCode === 200) {
          toast({
            title: 'Password changed',
            description: 'Password changed successfully',
          });
          setStatusState('changePassword', {
            status: true,
            loading: false,
          });
        } else {
          throw new Error('Failed to change password');
        }
      } catch (error) {
        setStatusState('changePassword', {
          status: false,
          loading: false,
        });
        if (error instanceof ApiResponseError) {
          setStatusState('changePassword', {
            error: error.details.description,
          });
        } else {
          toast({
            title: 'Error',
            description: `Unknown error when changing password: ${error}`,
            variant: 'destructive',
          });
        }
      } finally {
        setStatusState('changePassword', {
          loading: false,
        });
      }
    },
    [setStatusState, toast],
  );

  const contextValue = useMemo(
    () => ({
      onCreateAccountEphimeral,
      onDeleteAccountEphimeral,
      handleRefreshSession,
      handleForgotPassword,
      handleChangePassword,
      handleResetPassword,
      disconnectWallet,
      onCreateAccount,
      setStatusState,
      handleSignOut,
      connectWallet,
      handleSignUp,
      handleSignIn,
      statusState,
      wallet: cookieService.getAllWalletCookies(),
    }),
    [
      onCreateAccountEphimeral,
      onDeleteAccountEphimeral,
      handleRefreshSession,
      handleForgotPassword,
      handleChangePassword,
      handleResetPassword,
      disconnectWallet,
      onCreateAccount,
      setStatusState,
      handleSignOut,
      connectWallet,
      handleSignUp,
      handleSignIn,
      statusState,
    ],
  );

  return (
    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
  );
}
