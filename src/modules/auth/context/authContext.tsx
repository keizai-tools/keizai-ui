import { createContext, useCallback, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';

import { useStatusState } from '../hooks/useStatusState';
import {
  IAuthenticationContext,
  IWalletContent,
  IWallet,
} from '../interfaces/IAuthenticationContext';
import {
  SIGN_UP_SUCCESS_MESSAGE,
  CONFIRMATION_SENT_MESSAGE,
  UNRECOGNIZED_TOKEN_ERROR,
  SIGN_IN_SUCCESS_MESSAGE,
  SIGN_OUT_SUCCESS_MESSAGE,
} from '../message/auth-messages';
import { authService } from '../services/auth.service';

import { useToast } from '@/common/components/ui/use-toast';
import { NETWORK } from '@/common/types/soroban.enum';
import { ApiResponseError } from '@/config/axios/errors/ApiResponseError';
import { apiService } from '@/config/axios/services/api.service';
import { StoredCookies } from '@/modules/cookies/interfaces/cookies.enum';
import { cookieService } from '@/modules/cookies/services/cookie.service';
import { WalletType } from '@/modules/signer/constants/enums';
import signerConnectWallet from '@/modules/signer/functions/connectWallet';
import useStellar from '@/modules/stellar/hook/useStellar';

export const AuthContext = createContext<IAuthenticationContext | null>(null);

export function AuthProvider({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  const { statusState, setStatusState } = useStatusState();
  const { createNewAccount, fundingAccount } = useStellar();

  const navigate = useNavigate();
  const { toast } = useToast();

  const setConnectWallet = useCallback(
    (wallet: IWalletContent): void => {
      try {
        cookieService.setWalletCookie(wallet);
      } catch (error) {
        toast({
          title: 'Error',
          description: 'Failed to save wallet to local storage',
          variant: 'destructive',
        });
      }
    },
    [toast],
  );

  const onCreateAccount = useCallback(
    (
      showToast = true,
      refreshSession = false,
      wallets: IWallet = cookieService.getAllWalletCookies(),
      email: string = cookieService.getCookie(StoredCookies.EMAIL) ?? '',
    ) => {
      try {
        setStatusState('wallet', { loading: true });
        const keypair = createNewAccount();
        for (const network of [
          NETWORK.SOROBAN_TESTNET,
          NETWORK.SOROBAN_FUTURENET,
        ]) {
          if (
            refreshSession &&
            wallets[network] &&
            !wallets[network]?.autoGenerated &&
            wallets[network]?.email === email
          )
            continue;
          else if (keypair?.publicKey && keypair?.secretKey) {
            fundingAccount(network, keypair.publicKey);
            setConnectWallet({
              publicKey: keypair.publicKey,
              type: WalletType.SECRETKEY,
              network,
              autoGenerated: true,
              privateKey: keypair.secretKey,
              email: cookieService.getCookie(StoredCookies.EMAIL) ?? null,
            });
          }
        }
        if (showToast)
          toast({
            title: 'Account Created Successfully',
            description: 'Account created and funded on Testnet and Futurenet',
          });
      } catch (error) {
        toast({
          title: 'Error',
          description: 'Failed to create account',
          variant: 'destructive',
        });
      } finally {
        setStatusState('wallet', { loading: false });
      }
    },
    [createNewAccount, fundingAccount, setConnectWallet, setStatusState, toast],
  );

  const disconnectWallet = useCallback(
    (network?: Partial<NETWORK> | null, showToast = true): void => {
      try {
        if (network) {
          cookieService.removeWalletCookie(network);
          showToast &&
            toast({
              title: `Disconnected wallet from ${
                network.charAt(0).toUpperCase() +
                network.toLocaleLowerCase().slice(1)
              }`,
              description: 'Wallet disconnected successfully',
            });
          onCreateAccount(false, true);
        } else {
          cookieService.removeAllWalletCookies();
          showToast &&
            toast({
              title: 'Disconnected wallets',
              description: 'Wallets disconnected successfully',
            });
        }
      } catch (error) {
        toast({
          title: 'Error',
          description: 'Failed to disconnect wallet',
          variant: 'destructive',
        });
      }
    },
    [onCreateAccount, toast],
  );

  const connectWallet = useCallback(
    async (network: NETWORK): Promise<void> => {
      try {
        setStatusState('wallet', { loading: true });
        let response = await signerConnectWallet(network);
        if (!response?.publicKey || !response?.wallet)
          response = await signerConnectWallet(network);
        if (!response?.publicKey || !response?.wallet)
          throw new Error('Failed to connect wallet');
        setConnectWallet({
          publicKey: response.publicKey,
          type: response.wallet,
          network,
          email: cookieService.getCookie(StoredCookies.EMAIL) ?? null,
          autoGenerated: false,
        });
        toast({
          title: `Connected wallet to ${
            network.charAt(0).toUpperCase() +
            network.toLocaleLowerCase().slice(1)
          }`,
          description: 'Wallet connected successfully',
        });
      } catch (err: unknown) {
        console.error(err);

        if (err instanceof Error) {
          toast({
            title: "Couldn't connect wallet",
            description: err.message,
            variant: 'destructive',
          });
        }

        toast({
          title: 'Error',
          description: 'Please try again',
          variant: 'destructive',
        });
      }
      setStatusState('wallet', { loading: false });
    },
    [setConnectWallet, setStatusState, toast],
  );

  const handleSignUp = useCallback(
    async (email: string, password: string) => {
      async function signUp(email: string, password: string) {
        setStatusState('signUp', {
          loading: true,
        });
        try {
          const response = await authService.signUp(email, password);
          if (response.success && response.statusCode === 201) {
            toast({
              title: SIGN_UP_SUCCESS_MESSAGE,
              description: CONFIRMATION_SENT_MESSAGE,
            });
            setStatusState('signUp', {
              status: true,
              error: null,
              loading: false,
            });
            setStatusState('signIn', {
              error: null,
              loading: false,
            });
            navigate('/auth/login');
          } else {
            throw new Error('Failed to sign up');
          }
        } catch (error) {
          setStatusState('signUp', {
            status: false,
            error: null,
            loading: false,
          });
          if (error instanceof ApiResponseError) {
            setStatusState('signUp', { error: error.details.description });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when requesting creation of user: ${error}`,
              variant: 'destructive',
            });
          }
        } finally {
          setStatusState('signUp', {
            loading: false,
          });
        }
      }
      return signUp(email, password);
    },
    [navigate, setStatusState, toast],
  );

  const handleSignIn = useCallback(
    async (email: string, password: string) => {
      async function signIn(email: string, password: string) {
        setStatusState('signIn', {
          loading: true,
          error: null,
        });
        try {
          const response = await authService.signIn(email, password);
          const { payload } = response;
          const { accessToken, refreshToken, idToken } = payload;
          const decodedToken = cookieService.decodeToken(idToken);
          if (!decodedToken) throw new Error(UNRECOGNIZED_TOKEN_ERROR);

          cookieService.setAccessTokenCookie(accessToken);
          cookieService.setRefreshTokenCookie(refreshToken, decodedToken.exp);
          cookieService.setEmailCookie(email, decodedToken.exp);
          apiService.setAuthentication(accessToken);
          onCreateAccount(false, true);
          toast({
            title: SIGN_IN_SUCCESS_MESSAGE,
            description: `Welcome back, ${email}`,
          });
          setStatusState('signIn', { status: true });
          navigate('/');
        } catch (error) {
          setStatusState('signIn', { status: false });
          if (error instanceof ApiResponseError) {
            setStatusState('signIn', { error: error?.details?.description });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when requesting user sign in: ${error}`,
              variant: 'destructive',
            });
          }
        } finally {
          setStatusState('signIn', {
            loading: false,
          });
        }
      }
      return signIn(email, password);
    },
    [setStatusState, onCreateAccount, toast, navigate],
  );

  const handleForgotPassword = useCallback(
    (email: string) => {
      async function forgotPassword(email: string) {
        setStatusState('forgotPassword', {
          loading: true,
          error: null,
        });
        try {
          const response = await authService.forgotPassword(email);
          if (response.success && response.statusCode === 200) {
            toast({
              title: 'Password recovery',
              description: 'Password recovery email sent',
            });
            setStatusState('forgotPassword', {
              status: true,
              loading: false,
            });

            setStatusState('resetPassword', {
              error: null,
              loading: false,
              status: false,
              data: email,
            });

            navigate('/auth/reset-password');
          } else {
            throw new Error('Failed to request password change');
          }
        } catch (error) {
          setStatusState('forgotPassword', {
            status: false,
            loading: false,
          });
          if (error instanceof ApiResponseError) {
            setStatusState('forgotPassword', {
              error: error.details.description,
            });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when requesting password recovery: ${error}`,
              variant: 'destructive',
            });
          }
        } finally {
          setStatusState('forgotPassword', {
            loading: false,
          });
        }
      }
      return forgotPassword(email);
    },

    [navigate, setStatusState, toast],
  );

  const handleRefreshSession = useCallback(() => {
    async function refreshSession() {
      setStatusState('refreshSession', { loading: true });
      try {
        const email: string =
          cookieService.getCookie(StoredCookies.EMAIL) ?? '';
        const accessToken: string =
          cookieService.getCookie(StoredCookies.ACCESS_TOKEN) ?? '';
        const refreshToken: string =
          cookieService.getCookie(StoredCookies.REFRESH_TOKEN) ?? '';

        if (!email || !refreshToken) {
          setStatusState('refreshSession', {
            status: false,
            loading: false,
          });
          navigate('auth/login');
          return;
        }

        if (!accessToken) {
          const { payload } = await authService.refreshToken(
            email,
            refreshToken,
          );
          cookieService.setAccessTokenCookie(payload.accessToken);
          apiService.setAuthentication(payload.accessToken);
        }

        setStatusState('refreshSession', {
          status: true,
          loading: false,
        });
      } catch (error) {
        setStatusState('refreshSession', {
          status: false,
          loading: false,
        });

        if (error instanceof ApiResponseError) {
          setStatusState('refreshSession', {
            error: error.details.description,
          });

          if (error.details.description === 'Invalid Refresh Token') {
            cookieService.removeAll();
            cookieService.removeAllWalletCookies();
          } else {
            toast({
              title: 'Error',
              description: error.details.description,
              variant: 'destructive',
            });
          }
        } else {
          toast({
            title: 'Error',
            description: `Unknown error when refreshing session: ${error}`,
            variant: 'destructive',
          });
        }

        setStatusState('signIn', {
          error: null,
          loading: false,
        });
        navigate('auth/login');
      }
    }
    return refreshSession();
  }, [setStatusState, navigate, toast]);

  const handleSignOut = useCallback(() => {
    setStatusState('signOut', {
      loading: true,
    });
    try {
      cookieService.removeAll();
      apiService.setAuthentication('');
      disconnectWallet(null, false);
      toast({
        title: 'Sign out',
        description: SIGN_OUT_SUCCESS_MESSAGE,
      });
      setStatusState('signOut', {
        status: true,
        loading: false,
      });
      setStatusState('signIn', {
        error: null,
        loading: false,
      });
      navigate('/auth/login');
    } catch (error) {
      setStatusState('signOut', {
        status: false,
        loading: false,
      });
      toast({
        title: 'Error',
        description: `Unknown error when signing out: ${error}`,
        variant: 'destructive',
      });
    }
  }, [navigate, disconnectWallet, setStatusState, toast]);

  const handleResetPassword = useCallback(
    async (password: string, code: string, email?: string) => {
      const localEmail =
        cookieService.getCookie(StoredCookies.EMAIL) ??
        statusState.resetPassword.data ??
        email ??
        '';
      async function resetPassword({
        email,
        password,
        code,
      }: {
        email: string;
        password: string;
        code: string;
      }) {
        setStatusState('resetPassword', {
          loading: true,
          error: null,
        });
        try {
          const response = await authService.resetPassword(
            email,
            password,
            code,
          );
          if (response.success && response.statusCode === 200) {
            toast({
              title: 'Password reset',
              description: 'Password reset successful',
            });
            setStatusState('resetPassword', {
              status: true,
              loading: false,
            });
            setStatusState('signIn', {
              error: null,
              loading: false,
            });
            navigate('/auth/login');
          } else {
            throw new Error('Failed to reset password');
          }
        } catch (error) {
          setStatusState('resetPassword', {
            status: false,
            loading: false,
          });
          if (error instanceof ApiResponseError) {
            setStatusState('resetPassword', {
              error: error.details.description,
            });
            if (error.details.description === 'User not authorized') return;
            if (error.details.description !== 'Invalid refresh token')
              toast({
                title: 'Error',
                description: error.details.description,
                variant: 'destructive',
              });
          } else {
            toast({
              title: 'Error',
              description: `Unknown error when refreshing session: ${error}`,
              variant: 'destructive',
            });
          }
          setStatusState('resetPassword', {
            error: null,
            loading: false,
          });
          navigate('auth/login');
        }
      }
      return resetPassword({
        email: localEmail,
        password,
        code,
      });
    },
    [navigate, setStatusState, statusState.resetPassword.data, toast],
  );

  const handleChangePassword = useCallback(
    async (oldPassword: string, newPassword: string) => {
      setStatusState('changePassword', {
        loading: true,
        error: null,
      });
      try {
        const response = await authService.changePassword(
          newPassword,
          oldPassword,
        );
        if (response.success && response.statusCode === 200) {
          toast({
            title: 'Password changed',
            description: 'Password changed successfully',
          });
          setStatusState('changePassword', {
            status: true,
            loading: false,
          });
        } else {
          throw new Error('Failed to change password');
        }
      } catch (error) {
        setStatusState('changePassword', {
          status: false,
          loading: false,
        });
        if (error instanceof ApiResponseError) {
          setStatusState('changePassword', {
            error: error.details.description,
          });
        } else {
          toast({
            title: 'Error',
            description: `Unknown error when changing password: ${error}`,
            variant: 'destructive',
          });
        }
      } finally {
        setStatusState('changePassword', {
          loading: false,
        });
      }
    },
    [setStatusState, toast],
  );

  const contextValue = useMemo(
    () => ({
      handleRefreshSession,
      handleForgotPassword,
      handleChangePassword,
      handleResetPassword,
      disconnectWallet,
      onCreateAccount,
      setStatusState,
      handleSignOut,
      connectWallet,
      handleSignUp,
      handleSignIn,
      statusState,
      wallet: cookieService.getAllWalletCookies(),
    }),
    [
      handleRefreshSession,
      handleForgotPassword,
      handleChangePassword,
      handleResetPassword,
      disconnectWallet,
      onCreateAccount,
      setStatusState,
      handleSignOut,
      connectWallet,
      handleSignUp,
      handleSignIn,
      statusState,
    ],
  );

  return (
    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
  );
}
